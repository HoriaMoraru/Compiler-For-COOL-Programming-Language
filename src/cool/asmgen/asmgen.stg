////////////////////////////////////////////////////////////////////////
// Basic sequence rendering
////////////////////////////////////////////////////////////////////////
combineLines(e) ::= "<e; separator=\"\n\">"
spacedLines(e)  ::= "<e; separator=\"\n\n\">"
putWord(item) ::= <<
.word <item>
>>

////////////////////////////////////////////////////////////////////////
// Complete MIPS program generation
////////////////////////////////////////////////////////////////////////
program(
    integerData,
    stringData,
    classNamePointers,
    classProtoPointers,
    protoObjectDefs,
    allDispatchTables,
    classInits,
    methodData
) ::= <<
    ##################################################
    # Data Section Setup
    ##################################################
    .data
    .align 2

    .globl  class_nameTab
    .globl  Int_protObj
    .globl  String_protObj
    .globl  boolFalseConstant
    .globl  boolTrueConstant
    .globl  Main_protObj
    .globl  _int_tag
    .globl  _string_tag
    .globl  _bool_tag

_bool_tag:
    .word  4
_string_tag:
    .word  3
_int_tag:
    .word  2
# Base string constants for base class names
str_const0:
    .word   3
    .word   5
    .word   String_dispTab
    .word   int_const0
    .asciiz ""
    .align  2
str_const1:
    .word   3
    .word   6
    .word   String_dispTab
    .word   int_const1
    .asciiz "Object"
    .align  2
str_const2:
    .word   3
    .word   5
    .word   String_dispTab
    .word   int_const2
    .asciiz "IO"
    .align  2
str_const3:
    .word   3
    .word   5
    .word   String_dispTab
    .word   int_const3
    .asciiz "Int"
    .align  2
str_const4:
    .word   3
    .word   6
    .word   String_dispTab
    .word   int_const1
    .asciiz "String"
    .align  2
str_const5:
    .word   3
    .word   6
    .word   String_dispTab
    .word   int_const4
    .asciiz "Bool"
    .align  2
# Rest of string constants
<stringData>
# Int constants
<integerData>

# Boolean objects
boolFalseConstant:
    .word  4
    .word  4
    .word  Bool_dispTab
    .word  0

boolTrueConstant:
    .word  4
    .word  4
    .word  Bool_dispTab
    .word  1

# Table of class names
class_nameTab:
    .word str_const1
    .word str_const2
    .word str_const3
    .word str_const4
    .word str_const5
    <classNamePointers>

# Table for all class prototypes and initializers
allClassObjects:
    .word Object_protObj
    .word Object_init
    .word IO_protObj
    .word IO_init
    .word Int_protObj
    .word Int_init
    .word String_protObj
    .word String_init
    .word Bool_protObj
    .word Bool_init
    <classProtoPointers>

# Prototypes for base classes
Object_protObj:
    .word 0
    .word 3
    .word Object_dispTab

IO_protObj:
    .word 1
    .word 3
    .word IO_dispTab

Int_protObj:
    .word 2
    .word 4
    .word Int_dispTab
    .word 0

String_protObj:
    .word 3
    .word 5
    .word String_dispTab
    .word int_const0
    .asciiz ""
    .align 2

Bool_protObj:
    .word 4
    .word 4
    .word Bool_dispTab
    .word 0

# Prototypes for rest of classes
<protoObjectDefs>

##################################################
# Dispatch Tables (Method V-Tables)
##################################################
Object_dispTab:
    .word Object.abort
    .word Object.type_name
    .word Object.copy

IO_dispTab:
    .word Object.abort
    .word Object.type_name
    .word Object.copy
    .word IO.out_string
    .word IO.out_int
    .word IO.in_string
    .word IO.in_int

Int_dispTab:
    .word Object.abort
    .word Object.type_name
    .word Object.copy

String_dispTab:
    .word Object.abort
    .word Object.type_name
    .word Object.copy
    .word String.length
    .word String.concat
    .word String.substr

Bool_dispTab:
    .word Object.abort
    .word Object.type_name
    .word Object.copy

<allDispatchTables>

##################################################
# Beginning of Heap
##################################################
    .globl heap_start
heap_start:
    .word 0

##################################################
# Text Section Setup
##################################################
    .text
    .globl  Int_init
    .globl  String_init
    .globl  Bool_init
    .globl  Main_init
    .globl  Main.main

# Object initialization
Object_init:
    addiu  $sp, $sp, -12
    sw     $fp, 12($sp)
    sw     $s0, 8($sp)
    sw     $ra, 4($sp)
    addiu  $fp, $sp, 4
    move   $s0, $a0
    move   $a0, $s0
    lw     $fp, 12($sp)
    lw     $s0, 8($sp)
    lw     $ra, 4($sp)
    addiu  $sp, $sp, 12
    jr     $ra

# IO initialization
IO_init:
    addiu  $sp, $sp, -12
    sw     $fp, 12($sp)
    sw     $s0, 8($sp)
    sw     $ra, 4($sp)
    addiu  $fp, $sp, 4
    move   $s0, $a0
    jal    Object_init
    move   $a0, $s0
    lw     $fp, 12($sp)
    lw     $s0, 8($sp)
    lw     $ra, 4($sp)
    addiu  $sp, $sp, 12
    jr     $ra

# Int initialization
Int_init:
    addiu  $sp, $sp, -12
    sw     $fp, 12($sp)
    sw     $s0, 8($sp)
    sw     $ra, 4($sp)
    addiu  $fp, $sp, 4
    move   $s0, $a0
    jal    Object_init
    move   $a0, $s0
    lw     $fp, 12($sp)
    lw     $s0, 8($sp)
    lw     $ra, 4($sp)
    addiu  $sp, $sp, 12
    jr     $ra

# String initialization
String_init:
    addiu  $sp, $sp, -12
    sw     $fp, 12($sp)
    sw     $s0, 8($sp)
    sw     $ra, 4($sp)
    addiu  $fp, $sp, 4
    move   $s0, $a0
    jal    Object_init
    move   $a0, $s0
    lw     $fp, 12($sp)
    lw     $s0, 8($sp)
    lw     $ra, 4($sp)
    addiu  $sp, $sp, 12
    jr     $ra

# Bool initialization
Bool_init:
    addiu  $sp, $sp, -12
    sw     $fp, 12($sp)
    sw     $s0, 8($sp)
    sw     $ra, 4($sp)
    addiu  $fp, $sp, 4
    move   $s0, $a0
    jal    Object_init
    move   $a0, $s0
    lw     $fp, 12($sp)
    lw     $s0, 8($sp)
    lw     $ra, 4($sp)
    addiu  $sp, $sp, 12
    jr     $ra

# Rest of classes initialization
<classInits>
<methodData>
>>

////////////////////////////////////////////////////////////////////////
// Handling Constants and Prototypes
////////////////////////////////////////////////////////////////////////
intConstantDefinition(tag, val) ::= <<
int_const<tag>:
    .word 2
    .word 4
    .word Int_dispTab
    .word <val>
>>

strConstantDefinition(strTag, size, intTag, textVal) ::= <<
str_const<strTag>:
    .word 3
    .word <size>
    .word String_dispTab
    .word int_const<intTag>
    .asciiz "<textVal>"
    .align 2
>>

createProt(name, tag, size, dispTabName, fieldWords) ::= <<
<name>_protObj:
    .word <tag>
    .word <size>
    .word <dispTabName>_dispTab
    <fieldWords>
>>
////////////////////////////////////////////////////////////////////////
// Initializing classes
////////////////////////////////////////////////////////////////////////
initClass(thisClass, parentClass, attrSetup) ::= <<
<thisClass>_init:
    addiu $sp, $sp, -12
    sw    $fp, 12($sp)
    sw    $s0, 8($sp)
    sw    $ra, 4($sp)
    addiu $fp, $sp, 4
    move  $s0, $a0
    jal   <parentClass>_init
<attrSetup>
    move  $a0, $s0
    lw    $fp, 12($sp)
    lw    $s0, 8($sp)
    lw    $ra, 4($sp)
    addiu $sp, $sp, 12
    jr    $ra
>>
initAndProtAndMethodSet(prot, init, methodSet) ::= <<
<prototype>
<init>
<methodSet>
>>
////////////////////////////////////////////////////////////////////////
// Creating method tables
////////////////////////////////////////////////////////////////////////
createDispatchTable(thisClass, methodSet) ::= <<
<thisClass>_dispTab:
    .word Object.abort
    .word Object.type_name
    .word Object.copy
    <methodSet>
>>
////////////////////////////////////////////////////////////////////////
// MIPS Functions, Stack Handling
////////////////////////////////////////////////////////////////////////
defineMipsMethod(name, bodyInstr, freeParamInstr, freeLocalInstr, prepareLocals) ::= <<
<name>:
    addiu $sp, $sp, -12
    sw    $fp, 12($sp)
    sw    $s0, 8($sp)
    sw    $ra, 4($sp)
    addiu $fp, $sp, 4
<prepareLocals>
    move  $s0, $a0
<bodyInstr>
<freeLocalInstr>
    lw    $fp, 12($sp)
    lw    $s0, 8($sp)
    lw    $ra, 4($sp)
    addiu $sp, $sp, 12
<freeParamInstr>
    jr    $ra
>>

allocLocals(bytes) ::= <<
    addiu $sp, $sp, <bytes>   # local variable space
>>

freeParameters(bytes, paramAlias) ::= <<
    addiu $sp, $sp, <bytes>   # free param: <paramAlias>
>>

////////////////////////////////////////////////////////////////////////
// Expressions and Attribute Setup
////////////////////////////////////////////////////////////////////////
setAttribute(expressionPart, offsetVal) ::= <<
<expressionPart>
    sw $a0, <offsetVal>($s0)
>>

useLiteral(refLabel) ::= <<
    la $a0, <refLabel>
>>

invokeMethod(callerExpr, dispatchTag, fileLabel, lineNbr, offsetVal, paramLoads, grabTable) ::= <<
<paramLoads><callerExpr>
    bnez  $a0, dispatchJump<dispatchTag>
    la    $a0, str_const<fileLabel>
    li    $t1, <lineNbr>
    jal   _dispatch_abort
dispatchJump<dispatchTag>:
<grabTable>
    lw    $t1, <offsetVal>($t1)
    jalr  $t1
>>

loadSpecificTable(classTableName) ::= <<
    la $t1, <classTableName>_dispTab
>>

retrieveDispatchTable() ::= <<
    lw $t1, 8($a0)
>>

useSelfObject() ::= <<
    move $a0, $s0
>>

readAttribute(offsetVal) ::= <<
    lw $a0, <offsetVal>($s0)
>>

writeAttribute(offsetVal) ::= <<
    sw $a0, <offsetVal>($s0)
>>

readParam(offVal) ::= <<
    lw $a0, <offVal>($fp)
>>

writeParam(offVal) ::= <<
    sw $a0, <offVal>($fp)
>>

pushOneParam(loadParamStep) ::= <<
<loadParamStep>
    sw   $a0, 0($sp)
    addiu $sp, $sp, -4
>>

assignValue(doStore, doCompute) ::= <<
<doCompute>
<doStore>
>>

////////////////////////////////////////////////////////////////////////
// Let-Binding Structures
////////////////////////////////////////////////////////////////////////
combineLet(inits, bodyCode) ::= <<
<inits>
<bodyCode>
>>

setupLocal(initCode, localOff) ::= <<
<initCode>
    sw $a0, <localOff>($fp)
>>

////////////////////////////////////////////////////////////////////////
// Creating Objects
////////////////////////////////////////////////////////////////////////
makeNewObject(objClass) ::= <<
    la  $a0, <objClass>_protObj
    jal Object.copy
    jal <objClass>_init
>>

makeNewSelfType() ::= <<
    la   $t1, allClassObjects
    lw   $t2, 0($s0)      # retrieve class tag
    sll  $t2, $t2, 3      # multiply by 8
    addu $t1, $t1, $t2    # address offset
    sw   $t1, 0($sp)
    addiu $sp, $sp, -4
    lw   $a0, 0($t1)      # proto object
    jal  Object.copy
    lw   $t1, 4($sp)
    addiu $sp, $sp, 4
    lw   $t1, 4($t1)      # retrieve _init
    jalr $t1
>>

////////////////////////////////////////////////////////////////////////
// Conditionals
////////////////////////////////////////////////////////////////////////
ifExpression(condCode, thenPart, elsePart, uniqueID) ::= <<
<condCode>
    lw   $t1, 12($a0)    # bool data
    beqz $t1, elseBlock<uniqueID>
<thenPart>
    b    endIf<uniqueID>
elseBlock<uniqueID>:
<elsePart>
endIf<uniqueID>:
>>

checkVoid(exprSegment, markID) ::= <<
<exprSegment>
    move  $t1, $a0
    la    $a0, boolTrueConstant
    beqz  $t1, yesVoid<markID>
    la    $a0, boolFalseConstant
yesVoid<markID>:
>>

logicalNot(exprSegment, markID) ::= <<
<exprSegment>
    lw   $t1, 12($a0)   # bool data
    la   $a0, boolTrueConstant
    beqz $t1, notBlock<markID>
    la   $a0, boolFalseConstant
notBlock<markID>:
>>

////////////////////////////////////////////////////////////////////////
// Integer Arithmetic
////////////////////////////////////////////////////////////////////////
intAdd(op1, op2) ::= <<
<op1>
    sw    $a0, 0($sp)
    addiu $sp, $sp, -4
<op2>
    jal   Object.copy
    lw    $t1, 4($sp)
    addiu $sp, $sp, 4
    lw    $t1, 12($t1)
    lw    $t2, 12($a0)
    add   $t1, $t1, $t2
    sw    $t1, 12($a0)
>>

intSubtract(op1, op2) ::= <<
<op1>
    sw    $a0, 0($sp)
    addiu $sp, $sp, -4
<op2>
    jal   Object.copy
    lw    $t1, 4($sp)
    addiu $sp, $sp, 4
    lw    $t1, 12($t1)
    lw    $t2, 12($a0)
    sub   $t1, $t1, $t2
    sw    $t1, 12($a0)
>>

intMultiply(op1, op2) ::= <<
<op1>
    sw    $a0, 0($sp)
    addiu $sp, $sp, -4
<op2>
    jal   Object.copy
    lw    $t1, 4($sp)
    addiu $sp, $sp, 4
    lw    $t1, 12($t1)
    lw    $t2, 12($a0)
    mul   $t1, $t1, $t2
    sw    $t1, 12($a0)
>>

intDivide(op1, op2) ::= <<
<op1>
    sw    $a0, 0($sp)
    addiu $sp, $sp, -4
<op2>
    jal   Object.copy
    lw    $t1, 4($sp)
    addiu $sp, $sp, 4
    lw    $t1, 12($t1)
    lw    $t2, 12($a0)
    div   $t1, $t1, $t2
    sw    $t1, 12($a0)
>>

negateInt(exprVal) ::= <<
<exprVal>
    jal   Object.copy
    lw    $t1, 12($a0)
    neg   $t1, $t1
    sw    $t1, 12($a0)
>>

////////////////////////////////////////////////////////////////////////
// Comparisons
////////////////////////////////////////////////////////////////////////
testEquality(lhsExpr, rhsExpr, eqLabel) ::= <<
<lhsExpr>
    sw    $a0, 0($sp)
    addiu $sp, $sp, -4
<rhsExpr>
    lw    $t1, 4($sp)
    addiu $sp, $sp, 4
    move  $t2, $a0
    la    $a0, boolTrueConstant
    beq   $t1, $t2, eq<eqLabel>
    la    $a1, boolFalseConstant
    jal   equality_test
eq<eqLabel>:
>>

compareLess(lhsExpr, rhsExpr, cLabel) ::= <<
<lhsExpr>
    sw    $a0, 0($sp)
    addiu $sp, $sp, -4
<rhsExpr>
    lw    $t1, 4($sp)
    addiu $sp, $sp, 4
    lw    $t1, 12($t1)
    lw    $t2, 12($a0)
    la    $a0, boolTrueConstant
    blt   $t1, $t2, compare<cLabel>
    la    $a0, boolFalseConstant
compare<cLabel>:
>>

compareLessEq(lhsExpr, rhsExpr, cLabel) ::= <<
<lhsExpr>
    sw    $a0, 0($sp)
    addiu $sp, $sp, -4
<rhsExpr>
    lw    $t1, 4($sp)
    addiu $sp, $sp, 4
    lw    $t1, 12($t1)
    lw    $t2, 12($a0)
    la    $a0, boolTrueConstant
    ble   $t1, $t2, compare<cLabel>
    la    $a0, boolFalseConstant
compare<cLabel>:
>>

////////////////////////////////////////////////////////////////////////
// While Construct
////////////////////////////////////////////////////////////////////////
loopConstruct(condPart, loopStuff, loopID) ::= <<
repeat<loopID>:
<condPart>
    lw    $t1, 12($a0)
    beqz  $t1, endRepeat<loopID>
<loopStuff>
    b     repeat<loopID>
endRepeat<loopID>:
    move  $a0, $zero
>>

////////////////////////////////////////////////////////////////////////
// Case Statement
////////////////////////////////////////////////////////////////////////
caseBranchBlock(blockCode, lowerTag, upperTag, localID, doneID) ::= <<
    blt  $t1, <lowerTag>, caseBranch<localID>
    bgt  $t1, <upperTag>, caseBranch<localID>
<blockCode>
    b    endOfCase<doneID>
caseBranch<localID>:
>>

caseSwitcher(exprCode, branchSequences, caseID, finishID, fileLblID, lineVal) ::= <<
    move  $s0, $a0
<exprCode>
    bnez  $a0, performCase<caseID>
    la    $a0, str_const<fileLblID>
    li    $t1, <lineVal>
    jal   _case_abort2
performCase<caseID>:
    sw    $a0, -4($fp)
    lw    $t1, 0($a0)
<branchSequences>
    lw    $a0, -4($fp)
    jal   _case_abort
endOfCase<finishID>:
>>

////////////////////////////////////////////////////////////////////////
// Empty Initialization
////////////////////////////////////////////////////////////////////////
initAsNothing() ::= <<
    move $a0, $zero
>>
